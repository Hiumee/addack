package controller

import (
	"fmt"
	"net/http"
	"os"
	"path"
	"strconv"
	"strings"

	"github.com/hiumee/addack/src/model"

	"github.com/gin-gonic/gin"
)

func (c *Controller) GetExploits(context *gin.Context) {
	exploits, err := c.DB.GetExploits()
	if err != nil {
		context.HTML(http.StatusInternalServerError, "error", gin.H{"error": err.Error()})
		return
	}

	context.HTML(http.StatusOK, "exploits", gin.H{"Exploits": exploits})

	return
}

func (c *Controller) CreateExploit(context *gin.Context) {
	var exploit model.Exploit

	form, err := context.MultipartForm()
	if err != nil {
		fmt.Println(err)
		SendError(context, "An error occured parsing the form")
		return
	}

	exploit.Name = context.PostForm("name")
	exploit.Command = context.PostForm("command")
	cleanPath := path.Clean("/" + strings.Trim(context.PostForm("path"), "/"))
	exploit.Path = cleanPath
	exploit.Tag = context.PostForm("tag")
	exploit.Enabled = context.PostForm("enabled") == "on"
	exploit.Timeout, err = strconv.ParseInt(context.PostForm("timeout"), 10, 64)

	if err != nil {
		SendError(context, "Invalid timeout")
		return
	}

	if exploit.Name == "" || exploit.Command == "" || exploit.Path == "" {
		SendError(context, "All exploit fields must be filled out")
		return
	}

	id, err := c.DB.CreateExploit(exploit)
	if err != nil {
		SendError(context, err.Error())
		return
	}

	if _, err := os.Stat(c.Config.ExploitsPath); os.IsNotExist(err) {
		os.Mkdir(c.Config.ExploitsPath, 0755)
	}

	exploitPath := path.Join(c.Config.ExploitsPath, exploit.Path)

	if _, err := os.Stat(exploitPath); os.IsNotExist(err) {
		os.Mkdir(exploitPath, 0755)
	}

	for _, file := range form.File["files"] {
		filename := path.Base(file.Filename)
		err := context.SaveUploadedFile(file, path.Join(exploitPath, filename))
		if err != nil {
			fmt.Println(err)
			SendError(context, "Could not save file")
			return
		}
	}

	if exploit.Enabled {
		exploit.Id = id

		ex := exploit
		c.ExploitRunner.ExploitAdder <- &ex
	}

	context.HTML(http.StatusOK, "exploit-row-new", gin.H{"Name": exploit.Name, "Id": id, "Command": exploit.Command, "Notice": "Exploit created", "Tag": exploit.Tag, "Enabled": exploit.Enabled, "Flags": 0, "FlagsLast5Minutes": 0})
	return
}

func (c *Controller) DeleteExploit(context *gin.Context) {
	id, err := strconv.ParseInt(context.Param("id"), 10, 64)

	if err != nil {
		SendError(context, "Invalid ID")
		return
	}

	exploit, err := c.DB.GetExploit(id)
	if err != nil {
		SendError(context, "Could not find the exploit")
		return
	}
	err = c.DB.DeleteExploit(id)
	if err != nil {
		SendError(context, "Could not delete exploit")
		return
	}

	if exploit.Enabled {
		c.ExploitRunner.ExploitRemover <- &model.Exploit{Id: id}
	}

	context.HTML(http.StatusOK, "notice", gin.H{"Notice": "Exploit deleted"})
	return
}

func (c *Controller) DeleteAllExploits(context *gin.Context) {
	err := c.DB.DeleteAllExploits()
	if err != nil {
		SendError(context, "Could not delete all exploits")
		return
	}

	exploits := make([]*model.Exploit, 0)

	for _, exploit := range c.ExploitRunner.exploits {
		exploits = append(exploits, exploit)
	}

	for _, exploit := range exploits {
		ex := *exploit
		c.ExploitRunner.ExploitRemover <- &ex
	}

	c.GetExploits(context)

	return
}

func (c *Controller) ToggleExploit(context *gin.Context) {
	id, err := strconv.ParseInt(context.Param("id"), 10, 64)
	if err != nil {
		SendError(context, "Invalid ID")
		return
	}
	enable := context.Param("enable") == "enable"

	exploit, err := c.DB.GetExploit(id)
	if err != nil {
		SendError(context, "Could not get exploit")
		return
	}

	exploit.Enabled = enable

	err = c.DB.SetEnabledExploit(exploit)
	if err != nil {
		SendError(context, "Could not set enabled exploit")
		return
	}

	switch exploit.Enabled {
	case true:
		c.ExploitRunner.ExploitAdder <- &exploit
	case false:
		c.ExploitRunner.ExploitRemover <- &exploit
	}

	c.GetExploits(context)
	return
}
